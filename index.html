<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador 3D de Ecuaciones Avanzado</title>
    <style>
        /* Estilos base */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Estilos para menús colapsables */
        .menu-container {
            position: relative;
            width: 100%;
            margin-bottom: 15px;
            z-index: 1;
        }

        .menu-container:nth-child(1) { z-index: 4; }
        .menu-container:nth-child(2) { z-index: 3; }
        .menu-container:nth-child(3) { z-index: 2; }
        .menu-container:nth-child(4) { z-index: 1; }

        .collapsible {
            background-color: #2c3e50;
            color: white;
            cursor: pointer;
            padding: 15px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            border-radius: 8px;
            margin-bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            font-size: 1.1em;
            font-weight: 500;
            position: relative;
        }

        .collapsible:hover {
            background-color: #34495e;
        }

        .collapsible:after {
            content: '\002B';
            color: white;
            font-weight: bold;
            float: right;
            margin-left: 5px;
            transition: transform 0.3s ease;
        }

        .active:after {
            transform: rotate(45deg);
        }

        .panel {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease-out;
            background-color: #34495e;
            border-radius: 0 0 8px 8px;
            margin-top: 0;
            opacity: 0;
            transform: translateY(-10px);
            position: relative;
        }

        .panel.active {
            max-height: 2000px;
            padding: 15px;
            opacity: 1;
            transform: translateY(0);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Ajustes para móviles */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }

            .menu-container {
                margin-bottom: 10px;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .collapsible {
                padding: 12px;
                font-size: 1em;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .panel {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .panel.active {
                padding: 12px;
                margin-bottom: 10px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }

            .controls {
                width: 100%;
                max-width: 100%;
                margin: 10px 0;
                padding: 10px;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .control-group {
                margin-bottom: 15px;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .control-group label {
                display: block;
                margin-bottom: 5px;
                font-size: 0.9em;
            }

            .control-group input[type="range"] {
                width: 100%;
                margin: 5px 0;
                -webkit-appearance: none;
                height: 8px;
                background: #2c3e50;
                border-radius: 4px;
                outline: none;
            }

            .control-group input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 20px;
                height: 20px;
                background: #00bcd4;
                border-radius: 50%;
                cursor: pointer;
            }

            .control-group input[type="number"] {
                width: 60px;
                padding: 5px;
                font-size: 16px;
                border: 1px solid #2c3e50;
                border-radius: 4px;
                background: #34495e;
                color: white;
            }

            #graph-container {
                height: 300px;
                margin: 10px 0;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .examples {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 8px;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            .example-btn {
                padding: 8px;
                font-size: 0.9em;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }

            /* Mejoras específicas para móviles */
            .panel {
                position: relative;
                z-index: 1;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }

            .collapsible {
                position: relative;
                z-index: 2;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }

            /* Ajuste para evitar que el teclado virtual tape los controles */
            input[type="number"] {
                font-size: 16px;
            }

            /* Mejora en la accesibilidad táctil */
            button, 
            .example-btn,
            input[type="range"] {
                min-height: 44px;
            }

            /* Ajuste para el scroll suave */
            .panel.active {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }

            /* Prevenir scroll del body cuando un panel está abierto */
            body.panel-open {
                overflow: hidden;
            }
        }

        /* Ajustes para tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                padding: 15px;
            }

            #graph-container {
                height: 400px;
            }

            .examples {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }

        /* Ajustes para pantallas grandes */
        @media (min-width: 1025px) {
            .container {
                padding: 20px;
            }

            #graph-container {
                height: 500px;
            }

            .examples {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border: 2px solid #00bcd4;
            width: 90%;
            max-width: 600px;
        }
        
        #header h1 {
            margin: 0;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            color: #00bcd4;
            letter-spacing: 1px;
        }
        
        #header h2 {
            margin: 5px 0 0 0;
            font-size: clamp(12px, 3vw, 18px);
            font-weight: normal;
            color: white;
            opacity: 0.9;
        }
        
        #equation-panel {
            position: absolute;
            top: 100px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 400px;
            border: 2px solid #00bcd4;
        }
        
        #parameters {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid #00bcd4;
            width: 90%;
            max-width: 300px;
        }
        
        #examples {
            position: absolute;
            top: 100px;
            right: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 300px;
            border: 2px solid #00bcd4;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid #00bcd4;
            width: 90%;
            max-width: 300px;
        }

        .param-item {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
        }
        
        .param-label {
            font-size: clamp(12px, 2vw, 14px);
            margin-bottom: 5px;
            color: #00bcd4;
            font-weight: bold;
        }
        
        .param-value {
            font-size: clamp(11px, 1.5vw, 13px);
            color: #ccc;
            margin-bottom: 3px;
        }
        
        .param-slider {
            width: 100%;
        }
        
        .control-item {
            margin: 8px 0;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            font-family: 'Courier New', monospace;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        button {
            background: #00bcd4;
            border: none;
            padding: clamp(6px, 1.5vw, 8px) clamp(12px, 2vw, 15px);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 5px 5px 0;
            transition: background 0.3s;
            font-size: clamp(11px, 1.5vw, 13px);
        }
        
        button:hover {
            background: #0097a7;
        }
        
        .example-btn {
            background: #00bcd4;
            font-size: clamp(10px, 1.5vw, 12px);
            padding: 4px 8px;
            margin: 2px;
            color: white;
        }
        
        .example-btn:hover {
            background: #0097a7;
        }
        
        .error {
            color: #ff6b6b;
            font-size: clamp(11px, 1.5vw, 13px);
            margin-top: 5px;
        }
        
        .success {
            color: #00ff88;
            font-size: clamp(11px, 1.5vw, 13px);
            margin-top: 5px;
        }
        
        #equation-info {
            font-size: clamp(11px, 1.5vw, 13px);
            color: #ccc;
            margin-top: 10px;
            line-height: 1.4;
        }

        /* Estilos para el menú burger */
        .burger-menu {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: #2c3e50;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .burger-menu span {
            display: block;
            width: 25px;
            height: 3px;
            background: white;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .burger-menu.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .burger-menu.active span:nth-child(2) {
            opacity: 0;
        }

        .burger-menu.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        .side-menu {
            position: fixed;
            top: 0;
            right: -100%;
            width: 85%;
            max-width: 400px;
            height: 100vh;
            background: #1a1a1a;
            z-index: 999;
            transition: right 0.3s ease;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: -2px 0 5px rgba(0,0,0,0.2);
            padding: 20px;
            box-sizing: border-box;
        }

        .side-menu.active {
            right: 0;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                margin-top: 70px;
            }

            .burger-menu {
                top: 10px;
                right: 10px;
                width: 40px;
                height: 40px;
            }

            .burger-menu span {
                width: 20px;
                height: 2px;
            }

            .side-menu {
                width: 100%;
                max-width: none;
            }

            .menu-section {
                margin-bottom: 20px;
                padding: 15px;
                background: #2c3e50;
                border-radius: 8px;
            }

            .menu-section h3 {
                margin: 0 0 15px 0;
                color: white;
                font-size: 1.1em;
            }

            .control-group {
                margin-bottom: 15px;
            }

            .control-group label {
                display: block;
                margin-bottom: 5px;
                color: #fff;
            }

            .control-group input[type="range"] {
                width: 100%;
                margin: 5px 0;
            }

            .control-group input[type="number"] {
                width: 60px;
                padding: 5px;
                background: #34495e;
                border: 1px solid #2c3e50;
                color: white;
                border-radius: 4px;
            }

            .examples {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 8px;
            }

            .example-btn {
                padding: 8px;
                font-size: 0.9em;
                background: #34495e;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.3s ease;
            }

            .example-btn:hover {
                background: #2c3e50;
            }
        }
    </style>
</head>
<body>
    <button class="burger-menu">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <div class="menu-overlay"></div>

    <div class="side-menu">
        <div class="menu-section">
            <h3>Ecuación z = f(x, y)</h3>
            <div class="control-group">
                <input type="text" id="equation" placeholder="Ingrese la ecuación" value="sin(x) * cos(y)">
            </div>
            <div id="equation-info"></div>
        </div>

        <div class="menu-section">
            <h3>Ejemplos Populares</h3>
            <div class="examples">
                <button class="example-btn" onclick="setExample('sin(x) * cos(y)')">Onda Seno</button>
                <button class="example-btn" onclick="setExample('x^2 + y^2')">Paraboloide</button>
                <button class="example-btn" onclick="setExample('sin(sqrt(x^2 + y^2))')">Onda Circular</button>
                <button class="example-btn" onclick="setExample('x * y')">Silla de Montar</button>
                <button class="example-btn" onclick="setExample('exp(-(x^2 + y^2)/10)')">Campana</button>
                <button class="example-btn" onclick="setExample('sin(x) + cos(y)')">Onda Combinada</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Parámetros Dinámicos</h3>
            <div id="parameters"></div>
        </div>

        <div class="menu-section">
            <h3>Controles de Visualización</h3>
            <div class="controls">
                <div class="control-group">
                    <label for="resolution">Resolución:</label>
                    <input type="range" id="resolution" min="10" max="100" value="50">
                    <input type="number" id="resolution-value" value="50" min="10" max="100">
                </div>
                <div class="control-group">
                    <label for="scale">Escala:</label>
                    <input type="range" id="scale" min="1" max="10" step="0.1" value="1">
                    <input type="number" id="scale-value" value="1" min="1" max="10" step="0.1">
                </div>
                <div class="control-group">
                    <label for="rotation-speed">Velocidad de Rotación:</label>
                    <input type="range" id="rotation-speed" min="0" max="0.05" step="0.001" value="0.01">
                    <input type="number" id="rotation-speed-value" value="0.01" min="0" max="0.05" step="0.001">
                </div>
                <button id="toggle-rotation">Pausar Rotación</button>
                <button id="reset-view">Reiniciar Vista</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div id="graph-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.min.js"></script>
    <script>
        let scene, camera, renderer, surface, wireframe;
        let currentEquation = "A * sin(f*x + phi) * cos(f*y)";
        let showWireframe = true;
        let parameters = {
            A: 2.0,
            f: 2.0,
            phi: 0.0,
            Border_Factor: 0.1
        };
        let controls = {
            isMouseDown: false,
            mouseX: 0,
            mouseY: 0,
            rotationX: 0.3,
            rotationY: 0.5
        };

        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Agregar niebla para mejor visualización
            scene.fog = new THREE.Fog(0xf0f0f0, 10, 50);

            // Crear cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);

            // Crear renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Generar superficie inicial
            setTimeout(() => {
                setupParameterControls();
                generateSurface();
            }, 100);

            // Agregar luces
            addLights();

            // Agregar ejes de coordenadas
            addAxes();

            // Event listeners
            addEventListeners();

            // Iniciar animación
            animate();
        }

        function setupParameterControls() {
            ['A', 'f', 'phi', 'Border_Factor'].forEach(param => {
                document.getElementById(param).addEventListener('input', updateParameterValues);
            });
            
            document.getElementById('auto-update').addEventListener('change', () => {
                if (document.getElementById('auto-update').checked && currentEquation) {
                    generateSurface();
                }
            });
            
            // Inicializar valores
            updateParameterValues();
        }

        function updateParameterValues() {
            parameters.A = parseFloat(document.getElementById('A').value);
            parameters.f = parseFloat(document.getElementById('f').value);
            parameters.phi = parseFloat(document.getElementById('phi').value);
            parameters.Border_Factor = parseFloat(document.getElementById('Border_Factor').value);
            
            document.getElementById('A-value').textContent = parameters.A.toFixed(1);
            document.getElementById('f-value').textContent = parameters.f.toFixed(1);
            document.getElementById('phi-value').textContent = parameters.phi.toFixed(1);
            document.getElementById('Border_Factor-value').textContent = parameters.Border_Factor.toFixed(2);
            
            if (document.getElementById('auto-update').checked && currentEquation) {
                generateSurface();
            }
        }

        function loadExample(equation) {
            document.getElementById('equation').value = equation;
            generateSurface();
        }

        function resetView() {
            controls.rotationX = 0.3;
            controls.rotationY = 0.5;
            camera.position.set(8, 8, 8);
            updateCameraPosition();
        }

        function toggleWireframe() {
            showWireframe = !showWireframe;
            if (wireframe) {
                wireframe.visible = showWireframe;
            }
        }

        function validateAndParseEquation(equation) {
            try {
                // Crear una función de prueba
                const testExpr = math.parse(equation);
                const testCompiled = testExpr.compile();
                
                // Probar con valores de ejemplo incluyendo parámetros
                const testScope = {x: 1, y: 1, A: parameters.A, f: parameters.f, phi: parameters.phi, Border_Factor: parameters.Border_Factor};
                testCompiled.evaluate(testScope);
                testCompiled.evaluate({x: 0, y: 0, A: parameters.A, f: parameters.f, phi: parameters.phi, Border_Factor: parameters.Border_Factor});
                testCompiled.evaluate({x: -1, y: -1, A: parameters.A, f: parameters.f, phi: parameters.phi, Border_Factor: parameters.Border_Factor});
                
                return { success: true, compiled: testCompiled };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        function generateSurface() {
            const equationText = document.getElementById('equation').value.trim();
            const statusDiv = document.getElementById('equation-status');
            
            if (!equationText) {
                statusDiv.innerHTML = '<div class="error">Por favor ingresa una ecuación</div>';
                return;
            }

            const validation = validateAndParseEquation(equationText);
            
            if (!validation.success) {
                statusDiv.innerHTML = `<div class="error">Error: ${validation.error}</div>`;
                return;
            }

            statusDiv.innerHTML = '<div class="success">✓ Ecuación válida - Generando superficie...</div>';
            currentEquation = equationText;
            
            setTimeout(() => {
                try {
                    createSurface(validation.compiled);
                    statusDiv.innerHTML = '<div class="success">✓ Superficie generada correctamente</div>';
                } catch (error) {
                    statusDiv.innerHTML = `<div class="error">Error al generar: ${error.message}</div>`;
                }
            }, 100);
        }

        function createSurface(compiledEquation) {
            const resolution = parseInt(document.getElementById('resolution').value);
            const range = parseInt(document.getElementById('range').value);
            const thickness = parseFloat(document.getElementById('thickness').value);
            const zScale = parseFloat(document.getElementById('zScale').value);
            const opacity = parseFloat(document.getElementById('opacity').value);

            // Eliminar superficie anterior si existe
            if (surface) scene.remove(surface);
            if (wireframe) scene.remove(wireframe);

            // Crear geometría sólida con espesor
            const geometry = createSolidGeometry(resolution, range, thickness, zScale, compiledEquation);

            // Material para la superficie
            const material = new THREE.MeshPhongMaterial({
                color: 0x00bcd4,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide,
                shininess: 100
            });

            surface = new THREE.Mesh(geometry, material);
            surface.receiveShadow = true;
            surface.castShadow = true;
            scene.add(surface);

            // Crear wireframe
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });

            wireframe = new THREE.Mesh(geometry.clone(), wireframeMaterial);
            wireframe.visible = showWireframe;
            scene.add(wireframe);
        }

        function createSolidGeometry(resolution, range, thickness, zScale, compiledEquation) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // Función para calcular z según la ecuación compilada
            function calculateZ(x, y) {
                try {
                    const scope = {
                        x: x, 
                        y: y, 
                        A: parameters.A, 
                        f: parameters.f, 
                        phi: parameters.phi,
                        Border_Factor: parameters.Border_Factor
                    };
                    const result = compiledEquation.evaluate(scope);
                    if (typeof result !== 'number' || !isFinite(result)) {
                        return 0;
                    }
                    return result * zScale;
                } catch (error) {
                    return 0;
                }
            }

            // Crear grid de puntos
            const step = (range * 2) / resolution;
            const gridVertices = [];
            
            for (let i = 0; i <= resolution; i++) {
                gridVertices[i] = [];
                for (let j = 0; j <= resolution; j++) {
                    const x = -range + i * step;
                    const y = -range + j * step;
                    const z = calculateZ(x, y);
                    gridVertices[i][j] = { x, y, z };
                }
            }

            // Agregar vértices de la superficie superior
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const vertex = gridVertices[i][j];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }

            // Agregar vértices de la superficie inferior
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const vertex = gridVertices[i][j];
                    vertices.push(vertex.x, vertex.y, vertex.z - thickness);
                }
            }

            const pointsPerRow = resolution + 1;
            const totalTopPoints = pointsPerRow * pointsPerRow;

            // Crear caras para la superficie superior
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = i * pointsPerRow + j;
                    const b = i * pointsPerRow + (j + 1);
                    const c = (i + 1) * pointsPerRow + (j + 1);
                    const d = (i + 1) * pointsPerRow + j;

                    indices.push(a, b, c);
                    indices.push(a, c, d);
                }
            }

            // Crear caras para la superficie inferior (orden invertido)
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = totalTopPoints + i * pointsPerRow + j;
                    const b = totalTopPoints + i * pointsPerRow + (j + 1);
                    const c = totalTopPoints + (i + 1) * pointsPerRow + (j + 1);
                    const d = totalTopPoints + (i + 1) * pointsPerRow + j;

                    indices.push(a, c, b);
                    indices.push(a, d, c);
                }
            }

            // Crear caras laterales (bordes)
            // Borde i = 0 (izquierdo)
            for (let j = 0; j < resolution; j++) {
                const topA = 0 * pointsPerRow + j;
                const topB = 0 * pointsPerRow + (j + 1);
                const bottomA = totalTopPoints + 0 * pointsPerRow + j;
                const bottomB = totalTopPoints + 0 * pointsPerRow + (j + 1);

                indices.push(topA, bottomA, topB);
                indices.push(topB, bottomA, bottomB);
            }

            // Borde i = resolution (derecho)
            for (let j = 0; j < resolution; j++) {
                const topA = resolution * pointsPerRow + j;
                const topB = resolution * pointsPerRow + (j + 1);
                const bottomA = totalTopPoints + resolution * pointsPerRow + j;
                const bottomB = totalTopPoints + resolution * pointsPerRow + (j + 1);

                indices.push(topA, topB, bottomA);
                indices.push(topB, bottomB, bottomA);
            }

            // Borde j = 0 (frontal)
            for (let i = 0; i < resolution; i++) {
                const topA = i * pointsPerRow + 0;
                const topB = (i + 1) * pointsPerRow + 0;
                const bottomA = totalTopPoints + i * pointsPerRow + 0;
                const bottomB = totalTopPoints + (i + 1) * pointsPerRow + 0;

                indices.push(topA, topB, bottomA);
                indices.push(topB, bottomB, bottomA);
            }

            // Borde j = resolution (trasero)
            for (let i = 0; i < resolution; i++) {
                const topA = i * pointsPerRow + resolution;
                const topB = (i + 1) * pointsPerRow + resolution;
                const bottomA = totalTopPoints + i * pointsPerRow + resolution;
                const bottomB = totalTopPoints + (i + 1) * pointsPerRow + resolution;

                indices.push(topA, bottomA, topB);
                indices.push(topB, bottomA, bottomB);
            }

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();

            return geometry;
        }

        function addLights() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Luz direccional
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Luz puntual colorida
            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);
        }

        function addAxes() {
            // Eje X (rojo)
            const xGeometry = new THREE.CylinderGeometry(0.02, 0.02, 10);
            const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xGeometry, xMaterial);
            xAxis.rotation.z = Math.PI / 2;
            scene.add(xAxis);

            // Eje Y (verde)
            const yGeometry = new THREE.CylinderGeometry(0.02, 0.02, 10);
            const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yGeometry, yMaterial);
            scene.add(yAxis);

            // Eje Z (azul)
            const zGeometry = new THREE.CylinderGeometry(0.02, 0.02, 10);
            const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zGeometry, zMaterial);
            zAxis.rotation.x = Math.PI / 2;
            scene.add(zAxis);
        }

        function addEventListeners() {
            // Controles de mouse
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // Controles de interfaz
            document.getElementById('resolution').addEventListener('input', () => {
                if (currentEquation) generateSurface();
            });
            document.getElementById('range').addEventListener('input', () => {
                if (currentEquation) generateSurface();
            });
            document.getElementById('thickness').addEventListener('input', () => {
                if (currentEquation) generateSurface();
            });
            document.getElementById('zScale').addEventListener('input', () => {
                if (currentEquation) generateSurface();
            });
            document.getElementById('opacity').addEventListener('input', () => {
                if (currentEquation) generateSurface();
            });
            
            document.getElementById('exportSTL').addEventListener('click', exportSTL);
            document.getElementById('equation').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') generateSurface();
            });

            // Redimensionar ventana
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseDown(event) {
            controls.isMouseDown = true;
            controls.mouseX = event.clientX;
            controls.mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!controls.isMouseDown) return;

            const deltaX = event.clientX - controls.mouseX;
            const deltaY = event.clientY - controls.mouseY;

            controls.rotationY += deltaX * 0.01;
            controls.rotationX += deltaY * 0.01;

            controls.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, controls.rotationX));

            updateCameraPosition();

            controls.mouseX = event.clientX;
            controls.mouseY = event.clientY;
        }

        function onMouseUp(event) {
            controls.isMouseDown = false;
        }

        function onWheel(event) {
            const distance = camera.position.length();
            const newDistance = distance + event.deltaY * 0.01;
            
            if (newDistance > 2 && newDistance < 50) {
                const factor = newDistance / distance;
                camera.position.multiplyScalar(factor);
            }
        }

        function updateCameraPosition() {
            const distance = camera.position.length();
            camera.position.x = distance * Math.cos(controls.rotationX) * Math.cos(controls.rotationY);
            camera.position.y = distance * Math.sin(controls.rotationX);
            camera.position.z = distance * Math.cos(controls.rotationX) * Math.sin(controls.rotationY);
            camera.lookAt(0, 0, 0);
        }

        function exportSTL() {
            if (!surface) {
                alert('Primero genera una superficie');
                return;
            }

            const geometry = surface.geometry;
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index.array;

            let stlString = `solid ${currentEquation.replace(/[^a-zA-Z0-9]/g, '_')}\n`;

            for (let i = 0; i < indices.length; i += 3) {
                const a = indices[i] * 3;
                const b = indices[i + 1] * 3;
                const c = indices[i + 2] * 3;

                const v1 = new THREE.Vector3(vertices[a], vertices[a + 1], vertices[a + 2]);
                const v2 = new THREE.Vector3(vertices[b], vertices[b + 1], vertices[b + 2]);
                const v3 = new THREE.Vector3(vertices[c], vertices[c + 1], vertices[c + 2]);

                const cb = new THREE.Vector3();
                const ab = new THREE.Vector3();
                cb.subVectors(v3, v2);
                ab.subVectors(v1, v2);
                cb.cross(ab);
                cb.normalize();

                stlString += `  facet normal ${cb.x.toFixed(6)} ${cb.y.toFixed(6)} ${cb.z.toFixed(6)}\n`;
                stlString += '    outer loop\n';
                stlString += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                stlString += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                stlString += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                stlString += '    endloop\n';
                stlString += '  endfacet\n';
            }

            stlString += `endsolid ${currentEquation.replace(/[^a-zA-Z0-9]/g, '_')}`;

            const blob = new Blob([stlString], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ecuacion_3d_${currentEquation.replace(/[^a-zA-Z0-9]/g, '_')}.stl`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert('¡Archivo STL exportado exitosamente!');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!controls.isMouseDown) {
                controls.rotationY += 0.005;
                updateCameraPosition();
            }
            
            renderer.render(scene, camera);
        }

        // Inicializar cuando se carga la página
        init();

        // Agregar funcionalidad de menús colapsables
        document.addEventListener('DOMContentLoaded', function() {
            const coll = document.getElementsByClassName("collapsible");
            
            for (let i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    const panel = this.nextElementSibling;
                    
                    if (panel.style.maxHeight) {
                        panel.style.maxHeight = null;
                        panel.classList.remove("active");
                        document.body.classList.remove("panel-open");
                    } else {
                        // Cerrar otros paneles
                        const allPanels = document.getElementsByClassName("panel");
                        for (let j = 0; j < allPanels.length; j++) {
                            allPanels[j].style.maxHeight = null;
                            allPanels[j].classList.remove("active");
                        }
                        
                        panel.style.maxHeight = panel.scrollHeight + "px";
                        panel.classList.add("active");
                        document.body.classList.add("panel-open");
                        
                        // Scroll suave al panel abierto
                        setTimeout(() => {
                            this.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    }
                });
            }
        });

        // Agregar el manejo del menú burger
        document.addEventListener('DOMContentLoaded', function() {
            const burgerMenu = document.querySelector('.burger-menu');
            const sideMenu = document.querySelector('.side-menu');
            const menuOverlay = document.querySelector('.menu-overlay');

            function toggleMenu() {
                burgerMenu.classList.toggle('active');
                sideMenu.classList.toggle('active');
                menuOverlay.classList.toggle('active');
                document.body.style.overflow = sideMenu.classList.contains('active') ? 'hidden' : '';
            }

            burgerMenu.addEventListener('click', toggleMenu);
            menuOverlay.addEventListener('click', toggleMenu);

            // Cerrar menú al hacer click en un ejemplo
            document.querySelectorAll('.example-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (window.innerWidth <= 768) {
                        toggleMenu();
                    }
                });
            });
        });
    </script>
</body>
</html> 